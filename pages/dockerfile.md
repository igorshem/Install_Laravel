* [Оглавление](../README.md)

# 1. Dockerfile
* [ru инструкция](https://habr.com/ru/company/ruvds/blog/439980/)
* [eng инструкция более полная](https://kapeli.com/cheat_sheets/Dockerfile.docset/Contents/Resources/Documents/index)
* Dockerfile позволяет подключить только 1 (один) образ
## FROM
Задаётся базовый/родительский image, через двоеточие - версия. Всегда первая (в крайнем случае - вторая после ARG)
> FROM php:8.1-apache
## LABEL
Описывает метаданные, например - кто создал/сопровождает образ
> LABEL maintainer="jeffmshale@gmail.com"
## COPY
Связываем папки: текущую (first) и контейнерую (second). Копируем файлы/папки в контейнерю Создаёт слой.
> COPY . /var/www/html

* Если целевая папка не существует - будет создана. 
* При сборке проверяет внутренности файла прежде чем использовать кэш
## ADD
Копируем файлы и папки в контейнер (как COPY) +
* может распаковывать локальные *.tar архивы
* может загружать из удалённых источников
> ADD https://raw.githubusercontent.com/discdiver/pachy-vid/master/sample_vids/vid1.mp4 \
/my_app_directory

* Поддерживает символы разрыва строки "\" и слияние строк "&&". Для установки нескольких пакетов рекомендуется использовать, чтоб не плодить несколько слоёв и ускорить работу.
* Рекомендуется к замене на COPY, где возможно
* Создаёт слой
* При сборке проверяет внутренности файла прежде чем использовать кэш
## WORKDIR
* Рабочая попка контейнера для следующей инструкции.
* Используется: COPY, ADD, RUN, CMD и ENTRYPOINT.
* Предпочтительнее абсолютные пути, хотя и поддерживается команда 
**cd**.
* Если папка не существует - она будет создана
> WORKDIR /var/www/html
## EXPOSE
Используемый порт (рекомендация).
> EXPOSE 80
* Для перенаправления портов (командная строка -> **docker run**) используется ключ "-p"
* Для использования портов по-умолчанию используется ключ "-P"
## RUN
Выполнить команду и создать слой образа.
> RUN pip install --upgrade pip
> RUN adduser myuser
> RUN pip install --user -r requirements.txt
> RUN ["mkdir", "/a_directory"]

Поддерживает символы разрыва строки "\" и слияние строк "&&". Для установки нескольких пакетов рекомендуется использовать, чтоб не плодить несколько слоёв и ускорить работу.

Поддерживает 2-е формы вводимых команд:
exec-форма (JSON):
> RUN ["my_executable", "my_first_param1", "my_second_param2"]

shell-форма:
> RUN apk update && apk upgrade && apk add bash
## CMD
Команда с аргументами, которую надо выполнить когда контейнер запущен (only one, при наличии нескольких - выполняется последняя). Аргументы можно переопределять при запуске из коммандной строки (docker run). Если нет сиполняемого файла - следует заменить на ENTRYPOINT в формате JSON
> CMD ["python", "./my_script.py"]
> ENTRYPOINT ["python", "./app/my_script.py", "my_var"]
## ENTRYPOINT
Задаёт команду с аргументами, для выполнения при запуске контейнера.
* Отличие от CMD - аргументы не изменяются из командной строки при запуске, Но добавляются в конец списка аргументов.
* Рекомендуется exec-форма
* CMD рекомендуется использовать только когда аргументы требуют переопределения во время запуска
## ARG
Создание и задание переменной. 
* Доуступны только во время сборки образа => не доступны во время выполнения. 
* Можно использовать для задания ENV-переменных
> my_var=my_default_value
## ENV
Устанавливает постоянные переменные среды. Доступны в контейнере во время его выполнения.
> ENV ADMIN="jeff"
## VOLUME
Позволяет указать место, которое контейнер будет использовать для постоянного хранения файлов и для работы с такими файлами
## Комментарии
Комментарии - слева символ **#** (решетка)

# 2. Кэширование Docker
* В инструкциях ADD и COPY при работе с файлами, от Docker требуется проверка содержимого файла (контрольная сумма)
* Можно отключить ключем **--no-cache=True** в комманде **docker build**
* Для ускорения работы целесообразно инструкции, выроятность изменения которых высока, следует перемещать ближе к концу файла (следующая инструкция всегда не будет кешироваться)
* Объединять команды **RUN apt-get update** и **RUN apt-get install** в цепочки (см. п.1 #RUN)
* При использовании менеджеров пакетов (pip) с файлом **requirements.txt** следует придерживаться схемы, дабы исключить возможность использования данных из кеша:
```
COPY requirements.txt /tmp/
RUN pip install -r /tmp/requirements.txt
COPY . /tmp/
```

# 3 Уменьшение объёма, ускорение сборки
* сборки на основе alpine
* многоступенчатая сборка (множественное использование FROM)
```
FROM golang:1.7.3 AS build
WORKDIR /go/src/github.com/alexellis/href-counter/
RUN go get -d -v golang.org/x/net/html  
COPY app.go .
RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app .
FROM alpine:latest  
RUN apk --no-cache add ca-certificates
WORKDIR /root/
COPY --from=build /go/src/github.com/alexellis/href-counter/app .
CMD ["./app"]
```
Обратите внимание на то, что мы дали имя первой ступени сборки, указав его после инструкции FROM. К именованному этапу сборки мы обращаемся в инструкции COPY --from= ниже в Dockerfile.
* .dockerignore
[eng](https://docs.docker.com/engine/reference/builder/#dockerignore-file)
* Размер контейнера:
> docker container ls -s
* Размер images:
> docker image ls
* Размеры промежуточных образов, из которых собран некий образ:
> docker image history my_image:my_tag
* Размеры промежуточных слоёв, из которых собран некий образ:
> docker image inspect my_image:tag
* Для того чтобы исследовать содержимое контейнеров можно установить пакет [dive](https://github.com/wagoodman/dive)
## 3.1 Рекомендации
* Используйте всегда, когда это возможно, официальные образы в качестве базовых образов. Официальные образы регулярно обновляются, они безопаснее неофициальных образов.
* Для того чтобы собирать как можно более компактные образы, пользуйтесь базовыми образами, основанными на Alpine Linux.
* Если вы пользуетесь apt, комбинируйте в одной инструкции RUN команды apt-get update и apt-get install. Кроме того, объединяйте в одну инструкцию команды установки пакетов. Перечисляйте пакеты в алфавитном порядке на нескольких строках, разделяя список символами \.
* Включайте конструкцию вида && rm -rf /var/lib/apt/lists/* в конец инструкции RUN, используемой для установки пакетов. Это позволит очистить кэш apt и приведёт к тому, что он не будет сохраняться в слое, сформированном командой RUN.
* Разумно пользуйтесь возможностями кэширования, размещая в Dockerfile команды, вероятность изменения которых высока, ближе к концу файла.
* Пользуйтесь файлом .dockerignore.
* Взгляните на dive — отличный инструмент для исследования образов Docker, который помогает в деле уменьшения их размеров.
* Не устанавливайте в образы пакеты, без которых можно обойтись.

# 4 Команды
## 4.1 Управление контейнерами
Общая схема:
> docker container my_command

Где, my_command:
* create — создание контейнера из образа.
	- -a = (attach) - подключить контейнер к STDIN, STDOUT или STDERR
* start — запуск существующего контейнера.
* run — создание контейнера и его запуск.
	- -i = (interactive) - поток STDIN поддерживается в открытом состоянии даже если контейнер к STDIN не подключён.
	- -t = (tty) - выделяется псевдотерминал, который соединяет используемый терминал с потоками STDIN и STDOUT контейнера.
	- Для того чтобы получить возможность взаимодействия с контейнером через терминал нужно совместно использовать флаги -i и -t
	- -p = (port)  - перенаправление портов
	- --rm - автоматически удаляет контейнер после того, как его выполнение завершится.
	- -sh - создаст сессию терминала в контейнере, с которой можно взаимодействовать через ваш терминал. При работе с образами, основанными на Alpine, лучше ориентироваться на использование sh а не bash, так как в этих образах, по умолчанию, оболочка bash не установлена.
	- -d = (detach) - запуск контейнера в фоновом режиме. Это позволяет использовать терминал, из которого запущен контейнер, для выполнения других команд во время работы контейнера.
* ls — вывод списка работающих контейнеров.
	- -a = (all) - сведения обо всех контейнерах, а не только о выполняющихся.
	- -s = (size) - вывести размеры контейнеров.
* inspect — вывод подробной информации о контейнере.
* logs — вывод логов.
* stop — остановка работающего контейнера с отправкой главному процессу контейнера сигнала SIGTERM, и, через некоторое время, SIGKILL.
* kill — остановка работающего контейнера с отправкой главному процессу контейнера сигнала SIGKILL.
	- $(docker ps -q) - быстро остановить все работающие контейнеры
* rm — удаление остановленного контейнера.
	- $(docker ps -a -q) - удаление всех контейнеров, которые сейчас не выполняются

## 4.2 Управление образами
Общая схема:
> docker image my_command

Где, my_command:
* build — сборка образа.
	- -t = (tag) - создаваемому образу надо назначить предоставленный в команде тег
* push — отправка образа в удалённый реестр.
* ls — вывод списка образов.
* history — вывод сведений о слоях образа.
* inspect — вывод подробной информации об образе, в том числе — сведений о слоях.
* rm — удаление образа.
	- $(docker images -a -q) - удалить все локальные образы
## 4.3 Дополнительно
* docker version — вывод сведений о версиях клиента и сервера Docker.
* docker login — вход в реестр DockerHub.
* docker system prune — удаление неиспользуемых контейнеров, сетей и образов, которым не назначено имя и тег.
	- -a = (all) - удалить неиспользуемые образы, а не только те, которым не назначено имя и тег
